/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * client API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CategoriesListResponse,
  CategoryOut,
  CategoryProgressInfoOut,
  HTTPValidationError,
  IssueCreate,
  IssueOut,
  IssueTypeListResponse,
  IssuesListResponse,
  LevelProgressByCategoryStatistic,
  LevelsListResponse,
  ProgressByUserStatistic,
  QuestionGenerate,
  QuestionOut,
  QuestionUpdate,
  QuestionUpdateOut,
  ReadLevelsLevelsGetParams,
  TranslateOut,
  TranslateTextTranslateGetParams,
  UnlockLevelLevelsUnlockPostParams,
  UserOut
} from './client-schemas';

import { request } from '../shared/lib/apiClient/apiClient';
/**
 * @summary Read User
 */
export const readUserCurrentUserGet = (
    
 signal?: AbortSignal
) => {
      
      
      return request<UserOut>(
      {url: `/current_user`, method: 'GET', signal
    },
      );
    }
  

export const getReadUserCurrentUserGetQueryKey = () => {
    return [`/current_user`] as const;
    }

    
export const getReadUserCurrentUserGetQueryOptions = <TData = Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadUserCurrentUserGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readUserCurrentUserGet>>> = ({ signal }) => readUserCurrentUserGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadUserCurrentUserGetQueryResult = NonNullable<Awaited<ReturnType<typeof readUserCurrentUserGet>>>
export type ReadUserCurrentUserGetQueryError = unknown


export function useReadUserCurrentUserGet<TData = Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUserCurrentUserGet>>,
          TError,
          Awaited<ReturnType<typeof readUserCurrentUserGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUserCurrentUserGet<TData = Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUserCurrentUserGet>>,
          TError,
          Awaited<ReturnType<typeof readUserCurrentUserGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUserCurrentUserGet<TData = Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read User
 */

export function useReadUserCurrentUserGet<TData = Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUserCurrentUserGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadUserCurrentUserGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Category
 */
export const readCategoryCategoriesCategoryIdGet = (
    categoryId: number,
 signal?: AbortSignal
) => {
      
      
      return request<CategoryOut>(
      {url: `/categories/${categoryId}`, method: 'GET', signal
    },
      );
    }
  

export const getReadCategoryCategoriesCategoryIdGetQueryKey = (categoryId: number,) => {
    return [`/categories/${categoryId}`] as const;
    }

    
export const getReadCategoryCategoriesCategoryIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError = HTTPValidationError>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadCategoryCategoriesCategoryIdGetQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>> = ({ signal }) => readCategoryCategoriesCategoryIdGet(categoryId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadCategoryCategoriesCategoryIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>>
export type ReadCategoryCategoriesCategoryIdGetQueryError = HTTPValidationError


export function useReadCategoryCategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoryCategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoryCategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Category
 */

export function useReadCategoryCategoriesCategoryIdGet<TData = Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError = HTTPValidationError>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoryCategoriesCategoryIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadCategoryCategoriesCategoryIdGetQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Categories
 */
export const readCategoriesCategoriesGet = (
    
 signal?: AbortSignal
) => {
      
      
      return request<CategoriesListResponse>(
      {url: `/categories`, method: 'GET', signal
    },
      );
    }
  

export const getReadCategoriesCategoriesGetQueryKey = () => {
    return [`/categories`] as const;
    }

    
export const getReadCategoriesCategoriesGetQueryOptions = <TData = Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadCategoriesCategoriesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>> = ({ signal }) => readCategoriesCategoriesGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadCategoriesCategoriesGetQueryResult = NonNullable<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>>
export type ReadCategoriesCategoriesGetQueryError = unknown


export function useReadCategoriesCategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoriesCategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoriesCategoriesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoriesCategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readCategoriesCategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof readCategoriesCategoriesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadCategoriesCategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Categories
 */

export function useReadCategoriesCategoriesGet<TData = Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readCategoriesCategoriesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadCategoriesCategoriesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Levels
 */
export const readLevelsLevelsGet = (
    params?: ReadLevelsLevelsGetParams,
 signal?: AbortSignal
) => {
      
      
      return request<LevelsListResponse>(
      {url: `/levels`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getReadLevelsLevelsGetQueryKey = (params?: ReadLevelsLevelsGetParams,) => {
    return [`/levels`, ...(params ? [params]: [])] as const;
    }

    
export const getReadLevelsLevelsGetQueryOptions = <TData = Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError = HTTPValidationError>(params?: ReadLevelsLevelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadLevelsLevelsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readLevelsLevelsGet>>> = ({ signal }) => readLevelsLevelsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadLevelsLevelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof readLevelsLevelsGet>>>
export type ReadLevelsLevelsGetQueryError = HTTPValidationError


export function useReadLevelsLevelsGet<TData = Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError = HTTPValidationError>(
 params: undefined |  ReadLevelsLevelsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readLevelsLevelsGet>>,
          TError,
          Awaited<ReturnType<typeof readLevelsLevelsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadLevelsLevelsGet<TData = Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError = HTTPValidationError>(
 params?: ReadLevelsLevelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readLevelsLevelsGet>>,
          TError,
          Awaited<ReturnType<typeof readLevelsLevelsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadLevelsLevelsGet<TData = Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError = HTTPValidationError>(
 params?: ReadLevelsLevelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Levels
 */

export function useReadLevelsLevelsGet<TData = Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError = HTTPValidationError>(
 params?: ReadLevelsLevelsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readLevelsLevelsGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadLevelsLevelsGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Unlock Level
 */
export const unlockLevelLevelsUnlockPost = (
    params: UnlockLevelLevelsUnlockPostParams,
 signal?: AbortSignal
) => {
      
      
      return request<CategoryProgressInfoOut>(
      {url: `/levels/unlock`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getUnlockLevelLevelsUnlockPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockLevelLevelsUnlockPost>>, TError,{params: UnlockLevelLevelsUnlockPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unlockLevelLevelsUnlockPost>>, TError,{params: UnlockLevelLevelsUnlockPostParams}, TContext> => {

const mutationKey = ['unlockLevelLevelsUnlockPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlockLevelLevelsUnlockPost>>, {params: UnlockLevelLevelsUnlockPostParams}> = (props) => {
          const {params} = props ?? {};

          return  unlockLevelLevelsUnlockPost(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnlockLevelLevelsUnlockPostMutationResult = NonNullable<Awaited<ReturnType<typeof unlockLevelLevelsUnlockPost>>>
    
    export type UnlockLevelLevelsUnlockPostMutationError = HTTPValidationError

    /**
 * @summary Unlock Level
 */
export const useUnlockLevelLevelsUnlockPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockLevelLevelsUnlockPost>>, TError,{params: UnlockLevelLevelsUnlockPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof unlockLevelLevelsUnlockPost>>,
        TError,
        {params: UnlockLevelLevelsUnlockPostParams},
        TContext
      > => {

      const mutationOptions = getUnlockLevelLevelsUnlockPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Translate Text
 */
export const translateTextTranslateGet = (
    params: TranslateTextTranslateGetParams,
 signal?: AbortSignal
) => {
      
      
      return request<TranslateOut>(
      {url: `/translate`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getTranslateTextTranslateGetQueryKey = (params: TranslateTextTranslateGetParams,) => {
    return [`/translate`, ...(params ? [params]: [])] as const;
    }

    
export const getTranslateTextTranslateGetQueryOptions = <TData = Awaited<ReturnType<typeof translateTextTranslateGet>>, TError = HTTPValidationError>(params: TranslateTextTranslateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof translateTextTranslateGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTranslateTextTranslateGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof translateTextTranslateGet>>> = ({ signal }) => translateTextTranslateGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof translateTextTranslateGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TranslateTextTranslateGetQueryResult = NonNullable<Awaited<ReturnType<typeof translateTextTranslateGet>>>
export type TranslateTextTranslateGetQueryError = HTTPValidationError


export function useTranslateTextTranslateGet<TData = Awaited<ReturnType<typeof translateTextTranslateGet>>, TError = HTTPValidationError>(
 params: TranslateTextTranslateGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof translateTextTranslateGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof translateTextTranslateGet>>,
          TError,
          Awaited<ReturnType<typeof translateTextTranslateGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTranslateTextTranslateGet<TData = Awaited<ReturnType<typeof translateTextTranslateGet>>, TError = HTTPValidationError>(
 params: TranslateTextTranslateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof translateTextTranslateGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof translateTextTranslateGet>>,
          TError,
          Awaited<ReturnType<typeof translateTextTranslateGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTranslateTextTranslateGet<TData = Awaited<ReturnType<typeof translateTextTranslateGet>>, TError = HTTPValidationError>(
 params: TranslateTextTranslateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof translateTextTranslateGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Translate Text
 */

export function useTranslateTextTranslateGet<TData = Awaited<ReturnType<typeof translateTextTranslateGet>>, TError = HTTPValidationError>(
 params: TranslateTextTranslateGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof translateTextTranslateGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTranslateTextTranslateGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Generate Question
 */
export const generateQuestionQuestionsGeneratePost = (
    questionGenerate: QuestionGenerate,
 signal?: AbortSignal
) => {
      
      
      return request<QuestionOut>(
      {url: `/questions/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: questionGenerate, signal
    },
      );
    }
  


export const getGenerateQuestionQuestionsGeneratePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateQuestionQuestionsGeneratePost>>, TError,{data: QuestionGenerate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateQuestionQuestionsGeneratePost>>, TError,{data: QuestionGenerate}, TContext> => {

const mutationKey = ['generateQuestionQuestionsGeneratePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateQuestionQuestionsGeneratePost>>, {data: QuestionGenerate}> = (props) => {
          const {data} = props ?? {};

          return  generateQuestionQuestionsGeneratePost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateQuestionQuestionsGeneratePostMutationResult = NonNullable<Awaited<ReturnType<typeof generateQuestionQuestionsGeneratePost>>>
    export type GenerateQuestionQuestionsGeneratePostMutationBody = QuestionGenerate
    export type GenerateQuestionQuestionsGeneratePostMutationError = HTTPValidationError

    /**
 * @summary Generate Question
 */
export const useGenerateQuestionQuestionsGeneratePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateQuestionQuestionsGeneratePost>>, TError,{data: QuestionGenerate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateQuestionQuestionsGeneratePost>>,
        TError,
        {data: QuestionGenerate},
        TContext
      > => {

      const mutationOptions = getGenerateQuestionQuestionsGeneratePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Update Question Endpoint
 */
export const updateQuestionEndpointQuestionsQuestionIdPatch = (
    questionId: number,
    questionUpdate: QuestionUpdate,
 ) => {
      
      
      return request<QuestionUpdateOut>(
      {url: `/questions/${questionId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: questionUpdate
    },
      );
    }
  


export const getUpdateQuestionEndpointQuestionsQuestionIdPatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuestionEndpointQuestionsQuestionIdPatch>>, TError,{questionId: number;data: QuestionUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateQuestionEndpointQuestionsQuestionIdPatch>>, TError,{questionId: number;data: QuestionUpdate}, TContext> => {

const mutationKey = ['updateQuestionEndpointQuestionsQuestionIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateQuestionEndpointQuestionsQuestionIdPatch>>, {questionId: number;data: QuestionUpdate}> = (props) => {
          const {questionId,data} = props ?? {};

          return  updateQuestionEndpointQuestionsQuestionIdPatch(questionId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateQuestionEndpointQuestionsQuestionIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateQuestionEndpointQuestionsQuestionIdPatch>>>
    export type UpdateQuestionEndpointQuestionsQuestionIdPatchMutationBody = QuestionUpdate
    export type UpdateQuestionEndpointQuestionsQuestionIdPatchMutationError = HTTPValidationError

    /**
 * @summary Update Question Endpoint
 */
export const useUpdateQuestionEndpointQuestionsQuestionIdPatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuestionEndpointQuestionsQuestionIdPatch>>, TError,{questionId: number;data: QuestionUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateQuestionEndpointQuestionsQuestionIdPatch>>,
        TError,
        {questionId: number;data: QuestionUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateQuestionEndpointQuestionsQuestionIdPatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get Category Current Progress
 */
export const getCategoryCurrentProgress = (
    categoryId: number,
 signal?: AbortSignal
) => {
      
      
      return request<LevelProgressByCategoryStatistic>(
      {url: `/statistics/category-current-progress/${categoryId}`, method: 'GET', signal
    },
      );
    }
  

export const getGetCategoryCurrentProgressQueryKey = (categoryId: number,) => {
    return [`/statistics/category-current-progress/${categoryId}`] as const;
    }

    
export const getGetCategoryCurrentProgressQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError = HTTPValidationError>(categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryCurrentProgressQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryCurrentProgress>>> = ({ signal }) => getCategoryCurrentProgress(categoryId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryCurrentProgressQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryCurrentProgress>>>
export type GetCategoryCurrentProgressQueryError = HTTPValidationError


export function useGetCategoryCurrentProgress<TData = Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError = HTTPValidationError>(
 categoryId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryCurrentProgress>>,
          TError,
          Awaited<ReturnType<typeof getCategoryCurrentProgress>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryCurrentProgress<TData = Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError = HTTPValidationError>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryCurrentProgress>>,
          TError,
          Awaited<ReturnType<typeof getCategoryCurrentProgress>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryCurrentProgress<TData = Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError = HTTPValidationError>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Category Current Progress
 */

export function useGetCategoryCurrentProgress<TData = Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError = HTTPValidationError>(
 categoryId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryCurrentProgress>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryCurrentProgressQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Progress By User
 */
export const getProgressByUser = (
    
 signal?: AbortSignal
) => {
      
      
      return request<ProgressByUserStatistic>(
      {url: `/statistics/progress/`, method: 'GET', signal
    },
      );
    }
  

export const getGetProgressByUserQueryKey = () => {
    return [`/statistics/progress/`] as const;
    }

    
export const getGetProgressByUserQueryOptions = <TData = Awaited<ReturnType<typeof getProgressByUser>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgressByUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgressByUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgressByUser>>> = ({ signal }) => getProgressByUser(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgressByUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgressByUserQueryResult = NonNullable<Awaited<ReturnType<typeof getProgressByUser>>>
export type GetProgressByUserQueryError = unknown


export function useGetProgressByUser<TData = Awaited<ReturnType<typeof getProgressByUser>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgressByUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgressByUser>>,
          TError,
          Awaited<ReturnType<typeof getProgressByUser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgressByUser<TData = Awaited<ReturnType<typeof getProgressByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgressByUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgressByUser>>,
          TError,
          Awaited<ReturnType<typeof getProgressByUser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgressByUser<TData = Awaited<ReturnType<typeof getProgressByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgressByUser>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Progress By User
 */

export function useGetProgressByUser<TData = Awaited<ReturnType<typeof getProgressByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgressByUser>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgressByUserQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Today Progress By User
 */
export const getTodayProgressByUser = (
    
 signal?: AbortSignal
) => {
      
      
      return request<ProgressByUserStatistic>(
      {url: `/statistics/today_progress/`, method: 'GET', signal
    },
      );
    }
  

export const getGetTodayProgressByUserQueryKey = () => {
    return [`/statistics/today_progress/`] as const;
    }

    
export const getGetTodayProgressByUserQueryOptions = <TData = Awaited<ReturnType<typeof getTodayProgressByUser>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayProgressByUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTodayProgressByUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodayProgressByUser>>> = ({ signal }) => getTodayProgressByUser(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTodayProgressByUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTodayProgressByUserQueryResult = NonNullable<Awaited<ReturnType<typeof getTodayProgressByUser>>>
export type GetTodayProgressByUserQueryError = unknown


export function useGetTodayProgressByUser<TData = Awaited<ReturnType<typeof getTodayProgressByUser>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayProgressByUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayProgressByUser>>,
          TError,
          Awaited<ReturnType<typeof getTodayProgressByUser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodayProgressByUser<TData = Awaited<ReturnType<typeof getTodayProgressByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayProgressByUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTodayProgressByUser>>,
          TError,
          Awaited<ReturnType<typeof getTodayProgressByUser>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTodayProgressByUser<TData = Awaited<ReturnType<typeof getTodayProgressByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayProgressByUser>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Today Progress By User
 */

export function useGetTodayProgressByUser<TData = Awaited<ReturnType<typeof getTodayProgressByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTodayProgressByUser>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTodayProgressByUserQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Issue
 */
export const getIssueIssuesGet = (
    
 signal?: AbortSignal
) => {
      
      
      return request<IssuesListResponse>(
      {url: `/issues`, method: 'GET', signal
    },
      );
    }
  

export const getGetIssueIssuesGetQueryKey = () => {
    return [`/issues`] as const;
    }

    
export const getGetIssueIssuesGetQueryOptions = <TData = Awaited<ReturnType<typeof getIssueIssuesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueIssuesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIssueIssuesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIssueIssuesGet>>> = ({ signal }) => getIssueIssuesGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIssueIssuesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIssueIssuesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getIssueIssuesGet>>>
export type GetIssueIssuesGetQueryError = unknown


export function useGetIssueIssuesGet<TData = Awaited<ReturnType<typeof getIssueIssuesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueIssuesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssueIssuesGet>>,
          TError,
          Awaited<ReturnType<typeof getIssueIssuesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIssueIssuesGet<TData = Awaited<ReturnType<typeof getIssueIssuesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueIssuesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssueIssuesGet>>,
          TError,
          Awaited<ReturnType<typeof getIssueIssuesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIssueIssuesGet<TData = Awaited<ReturnType<typeof getIssueIssuesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueIssuesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Issue
 */

export function useGetIssueIssuesGet<TData = Awaited<ReturnType<typeof getIssueIssuesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueIssuesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetIssueIssuesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add Issue
 */
export const addIssueIssuesPost = (
    issueCreate: IssueCreate,
 signal?: AbortSignal
) => {
      
      
      return request<IssueOut>(
      {url: `/issues`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: issueCreate, signal
    },
      );
    }
  


export const getAddIssueIssuesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addIssueIssuesPost>>, TError,{data: IssueCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addIssueIssuesPost>>, TError,{data: IssueCreate}, TContext> => {

const mutationKey = ['addIssueIssuesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addIssueIssuesPost>>, {data: IssueCreate}> = (props) => {
          const {data} = props ?? {};

          return  addIssueIssuesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddIssueIssuesPostMutationResult = NonNullable<Awaited<ReturnType<typeof addIssueIssuesPost>>>
    export type AddIssueIssuesPostMutationBody = IssueCreate
    export type AddIssueIssuesPostMutationError = HTTPValidationError

    /**
 * @summary Add Issue
 */
export const useAddIssueIssuesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addIssueIssuesPost>>, TError,{data: IssueCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addIssueIssuesPost>>,
        TError,
        {data: IssueCreate},
        TContext
      > => {

      const mutationOptions = getAddIssueIssuesPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get Issue Types
 */
export const getIssueTypesIssueTypesGet = (
    
 signal?: AbortSignal
) => {
      
      
      return request<IssueTypeListResponse>(
      {url: `/issue_types`, method: 'GET', signal
    },
      );
    }
  

export const getGetIssueTypesIssueTypesGetQueryKey = () => {
    return [`/issue_types`] as const;
    }

    
export const getGetIssueTypesIssueTypesGetQueryOptions = <TData = Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIssueTypesIssueTypesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>> = ({ signal }) => getIssueTypesIssueTypesGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIssueTypesIssueTypesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>>
export type GetIssueTypesIssueTypesGetQueryError = unknown


export function useGetIssueTypesIssueTypesGet<TData = Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>,
          TError,
          Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIssueTypesIssueTypesGet<TData = Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>,
          TError,
          Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIssueTypesIssueTypesGet<TData = Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Issue Types
 */

export function useGetIssueTypesIssueTypesGet<TData = Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIssueTypesIssueTypesGet>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetIssueTypesIssueTypesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
